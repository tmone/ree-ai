name: Deploy to Production

on:
  push:
    branches: [ release ]  # Auto-deploy from release branch
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      confirm_deployment:
        description: 'Type "DEPLOY" to confirm'
        required: true
        default: 'CANCEL'

jobs:
  # ============================================================
  # PRE-DEPLOYMENT VALIDATION
  # ============================================================
  pre-deploy-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deploy_approved: ${{ steps.validation.outputs.approved }}
      deployment_env: ${{ steps.validation.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Validate deployment request
      id: validation
      run: |
        echo "üîç Validating deployment request..."
        
        # Determine deployment environment
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          DEPLOY_ENV="${{ github.event.inputs.environment }}"
          CONFIRMATION="${{ github.event.inputs.confirm_deployment }}"
          
          if [ "$CONFIRMATION" != "DEPLOY" ]; then
            echo "‚ùå Deployment requires confirmation!"
            echo "Please type 'DEPLOY' in the confirmation field"
            exit 1
          fi
          
          echo "‚úÖ Manual deployment confirmed for: $DEPLOY_ENV"
        else
          # Auto-deployment from push
          DEPLOY_ENV="production"
          echo "‚úÖ Auto-deployment triggered from release branch"
        fi
        
        # Validate branch
        if [ "${{ github.ref_name }}" != "release" ]; then
          echo "‚ùå Production deployment only allowed from release branch"
          echo "Current branch: ${{ github.ref_name }}"
          exit 1
        fi
        
        # Validate required files
        if [ ! -f "docker-compose.yml" ]; then
          echo "‚ùå docker-compose.yml not found"
          exit 1
        fi
        
        if [ ! -f "scripts/deploy-production.sh" ]; then
          echo "‚ùå Deployment script not found"
          exit 1
        fi
        
        echo "‚úÖ Pre-deployment validation passed"
        echo "approved=true" >> $GITHUB_OUTPUT
        echo "environment=$DEPLOY_ENV" >> $GITHUB_OUTPUT

  # ============================================================
  # DEPLOYMENT
  # ============================================================
  deploy:
    name: Deploy to ${{ needs.pre-deploy-checks.outputs.deployment_env }}
    runs-on: [self-hosted, linux, x64, production]
    timeout-minutes: 60
    needs: pre-deploy-checks
    if: needs.pre-deploy-checks.outputs.deploy_approved == 'true'
    
    environment: 
      name: ${{ needs.pre-deploy-checks.outputs.deployment_env }}
      url: http://${{ vars.SERVER_HOST || 'localhost' }}:3000

    steps:
    - name: Cleanup workspace
      run: |
        echo "üßπ Cleaning up workspace..."
        # Clean workspace contents but keep the directory structure
        cd /home/tmone/actions-runner-production/_work/ree-ai
        if [ -d "ree-ai" ]; then
          echo "Removing workspace contents..."
          rm -rf ree-ai/* ree-ai/.* 2>/dev/null || true
        fi
        # Ensure workspace directory exists
        mkdir -p ree-ai
        echo "‚úÖ Workspace cleanup completed"

    - name: Manual checkout
      run: |
        echo "üì• Manual checkout of repository..."
        # Use a unique temporary directory to avoid conflicts
        TEMP_DIR="/home/tmone/actions-runner-production/_work/ree-ai/ree-ai-$(date +%s)"
        
        # Clone fresh repository to temp directory
        git clone https://github.com/tmone/ree-ai.git "$TEMP_DIR"
        cd "$TEMP_DIR"
        git checkout release
        git pull origin release
        
        # Move to expected location
        if [ -d "/home/tmone/actions-runner-production/_work/ree-ai/ree-ai" ]; then
          mv "/home/tmone/actions-runner-production/_work/ree-ai/ree-ai" "/home/tmone/actions-runner-production/_work/ree-ai/ree-ai-old-$(date +%s)" || true
        fi
        mv "$TEMP_DIR" "/home/tmone/actions-runner-production/_work/ree-ai/ree-ai"
        echo "‚úÖ Repository checked out successfully"

    - name: Setup SSH for production server
      run: |
        echo "üîë Setting up SSH for production server..."
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/ree_ai_production_key
        chmod 600 ~/.ssh/ree_ai_production_key
        
        # Add production server to known hosts
        ssh-keyscan -H 192.168.1.12 >> ~/.ssh/known_hosts
        echo "‚úÖ SSH setup completed"

    - name: Setup deployment environment
      run: |
        echo "üõ†Ô∏è Setting up deployment environment..."
        
        # Make deployment script executable
        chmod +x scripts/deploy-production.sh
        
        # Validate environment variables
        if [ "${{ needs.pre-deploy-checks.outputs.deployment_env }}" = "production" ]; then
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "‚ùå OPENAI_API_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.JWT_SECRET_KEY }}" ]; then
            echo "‚ùå JWT_SECRET_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.WEBUI_SECRET_KEY }}" ]; then
            echo "‚ùå WEBUI_SECRET_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            echo "‚ùå PRODUCTION_SSH_KEY secret not configured"
            exit 1
          fi
        fi
        
        echo "‚úÖ Environment setup completed"

    - name: Deploy to Production Server
      env:
        DEPLOYMENT_ENV: ${{ needs.pre-deploy-checks.outputs.deployment_env }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        WEBUI_SECRET_KEY: ${{ secrets.WEBUI_SECRET_KEY }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'ree_ai_pass_2025' }}
        OPENSEARCH_PASSWORD: ${{ secrets.OPENSEARCH_PASSWORD || 'Admin123!@#' }}
        PROJECT_NAME: ree-ai
        LOG_LEVEL: INFO
        PRODUCTION_SERVER_IP: "192.168.1.12"
        PRODUCTION_SERVER_USER: "tmone"
      run: |
        echo "üöÄ Starting remote deployment to production server..."
        echo "Target: $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP"
        
        # Test SSH connectivity
        ssh -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP "echo 'SSH connection successful'"
        
        # Create deployment package
        echo "üì¶ Preparing deployment package..."
        cd /home/tmone/actions-runner-production/_work/ree-ai/
        tar -czf /tmp/ree-ai-deployment.tar.gz \
          --exclude='ree-ai/.git' \
          --exclude='ree-ai/node_modules' \
          --exclude='ree-ai/__pycache__' \
          --exclude='ree-ai/*.pyc' \
          --exclude='ree-ai/temp' \
          --exclude='ree-ai-old-*' \
          ree-ai
        
        # Copy deployment package to production server
        echo "üì§ Copying files to production server..."
        scp -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no /tmp/ree-ai-deployment.tar.gz $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP:~/
        
        # Execute deployment on production server
        echo "üöÄ Executing deployment on production server..."
        ssh -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP << 'EOF'
          set -e

          echo "üîÑ Extracting deployment package..."
          cd ~
          sudo rm -rf ree-ai-production-deploy
          mkdir -p ree-ai-production-deploy
          tar -xzf ree-ai-deployment.tar.gz -C ree-ai-production-deploy
          cd ree-ai-production-deploy/ree-ai
          
          echo "‚öôÔ∏è Setting up environment..."
          cat > .env << 'ENVEOF'
        # REE AI Production Environment Configuration
        POSTGRES_DB=ree_ai
        POSTGRES_USER=ree_ai_user
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'ree_ai_pass_2025' }}
        POSTGRES_HOST=postgres
        POSTGRES_PORT=5432
        
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        
        OPENSEARCH_HOST=opensearch
        OPENSEARCH_PORT=9200
        OPENSEARCH_PASSWORD=${{ secrets.OPENSEARCH_PASSWORD || 'Admin123!@#' }}
        
        WEBUI_SECRET_KEY=${{ secrets.WEBUI_SECRET_KEY }}
        JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
        JWT_ALGORITHM=HS256
        JWT_ACCESS_TOKEN_EXPIRE_MINUTES=60
        
        PRODUCTION_MODE=true
        USE_REAL_CORE_GATEWAY=true
        USE_REAL_DB_GATEWAY=true
        USE_ADVANCED_RAG=true
        
        DEBUG=false
        LOG_LEVEL=INFO
        
        ENABLE_FOLLOW_UP_GENERATION=true
        ENABLE_TITLE_GENERATION=true
        ENABLE_TAGS_GENERATION=true
        ENABLE_AUTOCOMPLETE_GENERATION=false
        
        MEMORY_RETENTION_DAYS=90
        MEMORY_CONSOLIDATION_THRESHOLD=10
        REFLECTION_QUALITY_THRESHOLD=0.7
        DOCUMENT_GRADER_THRESHOLD=0.5
        AGENT_TIMEOUT_SECONDS=30
        SUPERVISOR_MAX_RETRIES=2
        
        PROJECT_NAME=ree-ai
        ENVEOF
          
          echo "üê≥ Running staged deployment with Docker Compose..."
          export COMPOSE_PROFILES="real"
          
          # Stop existing services if any
          echo "Stopping existing services..."
          docker-compose down --remove-orphans || true

          # Pull external images first (postgres, redis, opensearch)
          echo "üì¶ Pulling external images..."
          docker-compose pull --ignore-pull-failures postgres redis opensearch || true

          # Build application services with new code
          echo "üî® Building application services..."
          docker-compose build --parallel || {
            echo "‚ö†Ô∏è Parallel build failed, trying sequential build..."
            docker-compose build
          }

          # Stage 1: Start base infrastructure services first
          echo "üöÄ Stage 1: Starting base infrastructure..."
          docker-compose up -d postgres redis opensearch
          
          # Wait for base services to be ready
          echo "‚è≥ Waiting for base infrastructure..."
          sleep 20
          
          # Stage 2: Start core services
          echo "üöÄ Stage 2: Starting core services..."
          docker-compose up -d service-registry core-gateway monitoring-service db-gateway
          
          # Wait for core services
          echo "‚è≥ Waiting for core services..."
          sleep 15
          
          # Stage 3: Start application services  
          echo "üöÄ Stage 3: Starting application services..."
          docker-compose up -d auth-service orchestrator rag-service
          
          # Wait for app services
          echo "‚è≥ Waiting for application services..."
          sleep 10
          
          # Stage 4: Start all remaining services
          echo "üöÄ Stage 4: Starting remaining services..."
          docker-compose up -d
          
          echo "‚úÖ Staged deployment completed!"
          echo "ÔøΩ Services will continue initializing in the background."
          
          # Show initial status
          echo "üìä Initial service status:"
          docker-compose ps
          
          # Cleanup
          cd ~
          rm -f ree-ai-deployment.tar.gz
        EOF

    - name: Post-deployment verification
      env:
        PRODUCTION_SERVER_IP: "192.168.1.12"
        PRODUCTION_SERVER_USER: "tmone"
      run: |
        echo "üß™ Running post-deployment verification..."
        
        # Quick verification - only wait for critical services
        sleep 15
        
        echo "üîç Testing critical services on production server..."
        ssh -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP << 'EOF'
          cd ~/ree-ai-production-deploy/ree-ai
          
          # Quick health checks for critical services only
          critical_services=(
            "localhost:8000/health|Service Registry"
            "localhost:8080/health|Core Gateway"
            "localhost:3000|Open WebUI"
          )
          
          failed_services=()
          
          for service_info in "${critical_services[@]}"; do
            IFS='|' read -r endpoint name <<< "$service_info"
            
            echo "Testing $name..."
            if timeout 5 curl -f "http://$endpoint" >/dev/null 2>&1; then
              echo "‚úÖ $name: OK"
            else
              echo "‚ö†Ô∏è $name: Not yet ready (services may still be initializing)"
              failed_services+=("$name")
            fi
          done
          
          echo "üìã Container status:"
          docker-compose ps --format "table {{.Service}}\t{{.State}}\t{{.Ports}}"
          
          # Don't fail deployment if services are still starting up
          if [ ${#failed_services[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è Some services still initializing: ${failed_services[*]}"
            echo "üïí Services will be available shortly. Check status manually if needed."
          else
            echo "‚úÖ All critical services are responding"
          fi
        EOF

    - name: Deployment summary
      if: always()
      env:
        PRODUCTION_SERVER_IP: "192.168.1.12"
      run: |
        # Get deployment information
        DEPLOYMENT_TIME=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
        
        cat << EOF
        
        ==========================================
        üöÄ REE AI Deployment Summary
        ==========================================
        Repository: ${{ github.repository }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Environment: ${{ needs.pre-deploy-checks.outputs.deployment_env }}
        Deployed by: ${{ github.actor }}
        Timestamp: $DEPLOYMENT_TIME
        Production Server: $PRODUCTION_SERVER_IP
        
        üåê Access URLs:
          - Open WebUI: http://$PRODUCTION_SERVER_IP:3000
          - Core Gateway: http://$PRODUCTION_SERVER_IP:8080
          - Service Registry: http://$PRODUCTION_SERVER_IP:8000
          - Orchestrator: http://$PRODUCTION_SERVER_IP:8090
          - RAG Service: http://$PRODUCTION_SERVER_IP:8091
          - Admin Dashboard: http://$PRODUCTION_SERVER_IP:3002
        
        üìä Infrastructure:
          - PostgreSQL: $PRODUCTION_SERVER_IP:5432
          - Redis: $PRODUCTION_SERVER_IP:6379  
          - OpenSearch: $PRODUCTION_SERVER_IP:9200
        
        üìã Remote Management:
          - SSH: ssh tmone@$PRODUCTION_SERVER_IP
          - View logs: ssh tmone@$PRODUCTION_SERVER_IP 'cd ~/ree-ai-production-deploy && sudo docker-compose logs [service]'
          - Stop services: ssh tmone@$PRODUCTION_SERVER_IP 'cd ~/ree-ai-production-deploy && sudo docker-compose down'
          - Service status: ssh tmone@$PRODUCTION_SERVER_IP 'cd ~/ree-ai-production-deploy && sudo docker-compose ps'
        
        Status: ${{ job.status == 'success' && '‚úÖ SUCCESS' || '‚ùå FAILED' }}
        ==========================================
        
        EOF