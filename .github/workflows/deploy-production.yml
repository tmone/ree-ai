name: Deploy to Production

on:
  push:
    branches: [ release ]  # Auto-deploy from release branch
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      confirm_deployment:
        description: 'Type "DEPLOY" to confirm'
        required: true
        default: 'CANCEL'

jobs:
  # ============================================================
  # PRE-DEPLOYMENT VALIDATION
  # ============================================================
  pre-deploy-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deploy_approved: ${{ steps.validation.outputs.approved }}
      deployment_env: ${{ steps.validation.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Validate deployment request
      id: validation
      run: |
        echo "üîç Validating deployment request..."
        
        # Determine deployment environment
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          DEPLOY_ENV="${{ github.event.inputs.environment }}"
          CONFIRMATION="${{ github.event.inputs.confirm_deployment }}"
          
          if [ "$CONFIRMATION" != "DEPLOY" ]; then
            echo "‚ùå Deployment requires confirmation!"
            echo "Please type 'DEPLOY' in the confirmation field"
            exit 1
          fi
          
          echo "‚úÖ Manual deployment confirmed for: $DEPLOY_ENV"
        else
          # Auto-deployment from push
          DEPLOY_ENV="production"
          echo "‚úÖ Auto-deployment triggered from release branch"
        fi
        
        # Validate branch
        if [ "${{ github.ref_name }}" != "release" ]; then
          echo "‚ùå Production deployment only allowed from release branch"
          echo "Current branch: ${{ github.ref_name }}"
          exit 1
        fi
        
        # Validate required files
        if [ ! -f "docker-compose.yml" ]; then
          echo "‚ùå docker-compose.yml not found"
          exit 1
        fi
        
        if [ ! -f "scripts/deploy-production.sh" ]; then
          echo "‚ùå Deployment script not found"
          exit 1
        fi
        
        echo "‚úÖ Pre-deployment validation passed"
        echo "approved=true" >> $GITHUB_OUTPUT
        echo "environment=$DEPLOY_ENV" >> $GITHUB_OUTPUT

  # ============================================================
  # DEPLOYMENT
  # ============================================================
  deploy:
    name: Deploy to ${{ needs.pre-deploy-checks.outputs.deployment_env }}
    runs-on: [self-hosted, linux, x64, production]
    timeout-minutes: 30
    needs: pre-deploy-checks
    if: needs.pre-deploy-checks.outputs.deploy_approved == 'true'
    
    environment: 
      name: ${{ needs.pre-deploy-checks.outputs.deployment_env }}
      url: http://${{ vars.SERVER_HOST || 'localhost' }}:3000

    steps:
    - name: Cleanup workspace
      run: |
        echo "üßπ Cleaning up workspace..."
        # Remove any existing __pycache__ directories with permission issues
        sudo find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
        sudo find . -name "*.pyc" -type f -delete 2>/dev/null || true
        echo "‚úÖ Workspace cleanup completed"
      
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        clean: false
        fetch-depth: 1

    - name: Setup SSH for production server
      run: |
        echo "üîë Setting up SSH for production server..."
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/ree_ai_production_key
        chmod 600 ~/.ssh/ree_ai_production_key
        
        # Add production server to known hosts
        ssh-keyscan -H 192.168.1.12 >> ~/.ssh/known_hosts
        echo "‚úÖ SSH setup completed"

    - name: Setup deployment environment
      run: |
        echo "üõ†Ô∏è Setting up deployment environment..."
        
        # Make deployment script executable
        chmod +x scripts/deploy-production.sh
        
        # Validate environment variables
        if [ "${{ needs.pre-deploy-checks.outputs.deployment_env }}" = "production" ]; then
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "‚ùå OPENAI_API_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.JWT_SECRET_KEY }}" ]; then
            echo "‚ùå JWT_SECRET_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.WEBUI_SECRET_KEY }}" ]; then
            echo "‚ùå WEBUI_SECRET_KEY secret not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            echo "‚ùå PRODUCTION_SSH_KEY secret not configured"
            exit 1
          fi
        fi
        
        echo "‚úÖ Environment setup completed"

    - name: Deploy to Production Server
      env:
        DEPLOYMENT_ENV: ${{ needs.pre-deploy-checks.outputs.deployment_env }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        WEBUI_SECRET_KEY: ${{ secrets.WEBUI_SECRET_KEY }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'ree_ai_pass_2025' }}
        OPENSEARCH_PASSWORD: ${{ secrets.OPENSEARCH_PASSWORD || 'Admin123!@#' }}
        PROJECT_NAME: ree-ai
        LOG_LEVEL: INFO
        PRODUCTION_SERVER_IP: "192.168.1.12"
        PRODUCTION_SERVER_USER: "tmone"
      run: |
        echo "üöÄ Starting remote deployment to production server..."
        echo "Target: $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP"
        
        # Test SSH connectivity
        ssh -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP "echo 'SSH connection successful'"
        
        # Create deployment package
        echo "üì¶ Preparing deployment package..."
        tar -czf ree-ai-deployment.tar.gz \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='__pycache__' \
          --exclude='*.pyc' \
          --exclude='temp' \
          .
        
        # Copy deployment package to production server
        echo "üì§ Copying files to production server..."
        scp -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no ree-ai-deployment.tar.gz $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP:~/
        
        # Execute deployment on production server
        echo "üöÄ Executing deployment on production server..."
        ssh -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP << 'EOF'
          set -e
          
          echo "üîÑ Extracting deployment package..."
          cd ~
          rm -rf ree-ai-production-deploy
          mkdir -p ree-ai-production-deploy
          tar -xzf ree-ai-deployment.tar.gz -C ree-ai-production-deploy
          cd ree-ai-production-deploy
          
          echo "‚öôÔ∏è Setting up environment..."
          cat > .env << 'ENVEOF'
        # REE AI Production Environment Configuration
        POSTGRES_DB=ree_ai
        POSTGRES_USER=ree_ai_user
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'ree_ai_pass_2025' }}
        POSTGRES_HOST=postgres
        POSTGRES_PORT=5432
        
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        
        OPENSEARCH_HOST=opensearch
        OPENSEARCH_PORT=9200
        OPENSEARCH_PASSWORD=${{ secrets.OPENSEARCH_PASSWORD || 'Admin123!@#' }}
        
        WEBUI_SECRET_KEY=${{ secrets.WEBUI_SECRET_KEY }}
        JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
        JWT_ALGORITHM=HS256
        JWT_ACCESS_TOKEN_EXPIRE_MINUTES=60
        
        PRODUCTION_MODE=true
        USE_REAL_CORE_GATEWAY=true
        USE_REAL_DB_GATEWAY=true
        USE_ADVANCED_RAG=true
        
        DEBUG=false
        LOG_LEVEL=INFO
        
        ENABLE_FOLLOW_UP_GENERATION=true
        ENABLE_TITLE_GENERATION=true
        ENABLE_TAGS_GENERATION=true
        ENABLE_AUTOCOMPLETE_GENERATION=false
        
        MEMORY_RETENTION_DAYS=90
        MEMORY_CONSOLIDATION_THRESHOLD=10
        REFLECTION_QUALITY_THRESHOLD=0.7
        DOCUMENT_GRADER_THRESHOLD=0.5
        AGENT_TIMEOUT_SECONDS=30
        SUPERVISOR_MAX_RETRIES=2
        
        PROJECT_NAME=ree-ai
        ENVEOF
          
          echo "üê≥ Running deployment with Docker Compose..."
          export COMPOSE_PROFILES="real"
          
          # Stop existing services if any
          sudo docker-compose down --remove-orphans || true
          
          # Pull latest images and start services
          sudo docker-compose pull --ignore-pull-failures || true
          sudo docker-compose up -d --build --remove-orphans
          
          echo "‚úÖ Deployment completed on production server!"
          
          # Show running services
          echo "üìä Running services:"
          sudo docker-compose ps
          
          # Cleanup
          cd ~
          rm -f ree-ai-deployment.tar.gz
        EOF

    - name: Post-deployment verification
      env:
        PRODUCTION_SERVER_IP: "192.168.1.12"
        PRODUCTION_SERVER_USER: "tmone"
      run: |
        echo "üß™ Running post-deployment verification..."
        
        # Wait for services to stabilize
        sleep 30
        
        echo "üîç Testing services on production server..."
        ssh -i ~/.ssh/ree_ai_production_key -o StrictHostKeyChecking=no $PRODUCTION_SERVER_USER@$PRODUCTION_SERVER_IP << 'EOF'
          cd ~/ree-ai-production-deploy
          
          # Advanced health checks
          services=(
            "localhost:8000/health|Service Registry"
            "localhost:8080/health|Core Gateway"
            "localhost:8081/health|DB Gateway"
            "localhost:8090/health|Orchestrator"
            "localhost:8091/health|RAG Service"
            "localhost:3000|Open WebUI"
          )
          
          failed_services=()
          
          for service_info in "${services[@]}"; do
            IFS='|' read -r endpoint name <<< "$service_info"
            
            echo "Testing $name..."
            if timeout 10 curl -f "http://$endpoint" >/dev/null 2>&1; then
              echo "‚úÖ $name: OK"
            else
              echo "‚ùå $name: FAILED"
              failed_services+=("$name")
            fi
          done
          
          if [ ${#failed_services[@]} -eq 0 ]; then
            echo "‚úÖ All services are healthy"
          else
            echo "‚ö†Ô∏è Failed services: ${failed_services[*]}"
            echo "üìã Service status:"
            sudo docker-compose ps
            
            # Don't fail deployment for non-critical services
            echo "üîç Checking critical services only..."
            critical_services=("Service Registry" "Core Gateway")
            critical_failed=()
            
            for service in "${critical_services[@]}"; do
              if [[ " ${failed_services[*]} " =~ " ${service} " ]]; then
                critical_failed+=("$service")
              fi
            done
            
            if [ ${#critical_failed[@]} -gt 0 ]; then
              echo "‚ùå Critical services failed: ${critical_failed[*]}"
              exit 1
            else
              echo "‚úÖ Critical services are healthy"
            fi
          fi
        EOF

    - name: Deployment summary
      if: always()
      env:
        PRODUCTION_SERVER_IP: "192.168.1.12"
      run: |
        # Get deployment information
        DEPLOYMENT_TIME=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
        
        cat << EOF
        
        ==========================================
        üöÄ REE AI Deployment Summary
        ==========================================
        Repository: ${{ github.repository }}
        Branch: ${{ github.ref_name }}
        Commit: ${{ github.sha }}
        Environment: ${{ needs.pre-deploy-checks.outputs.deployment_env }}
        Deployed by: ${{ github.actor }}
        Timestamp: $DEPLOYMENT_TIME
        Production Server: $PRODUCTION_SERVER_IP
        
        üåê Access URLs:
          - Open WebUI: http://$PRODUCTION_SERVER_IP:3000
          - Core Gateway: http://$PRODUCTION_SERVER_IP:8080
          - Service Registry: http://$PRODUCTION_SERVER_IP:8000
          - Orchestrator: http://$PRODUCTION_SERVER_IP:8090
          - RAG Service: http://$PRODUCTION_SERVER_IP:8091
          - Admin Dashboard: http://$PRODUCTION_SERVER_IP:3002
        
        üìä Infrastructure:
          - PostgreSQL: $PRODUCTION_SERVER_IP:5432
          - Redis: $PRODUCTION_SERVER_IP:6379  
          - OpenSearch: $PRODUCTION_SERVER_IP:9200
        
        üìã Remote Management:
          - SSH: ssh tmone@$PRODUCTION_SERVER_IP
          - View logs: ssh tmone@$PRODUCTION_SERVER_IP 'cd ~/ree-ai-production-deploy && sudo docker-compose logs [service]'
          - Stop services: ssh tmone@$PRODUCTION_SERVER_IP 'cd ~/ree-ai-production-deploy && sudo docker-compose down'
          - Service status: ssh tmone@$PRODUCTION_SERVER_IP 'cd ~/ree-ai-production-deploy && sudo docker-compose ps'
        
        Status: ${{ job.status == 'success' && '‚úÖ SUCCESS' || '‚ùå FAILED' }}
        ==========================================
        
        EOF